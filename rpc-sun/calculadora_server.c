/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"
#include "math.h"

readdir_res *
readdir_1_svc(nametype arg1,  struct svc_req *rqstp)
{
	static readdir_res  result;

	/*
	 * insert server code here
	 */

	return &result;
}

float *
sum_1_svc(float arg1, float arg2,  struct svc_req *rqstp)
{
	static float  result;

	result = arg1 + arg2;

	return &result;
}

float *
substract_1_svc(float arg1, float arg2,  struct svc_req *rqstp)
{
	static float  result;

	result = arg1 - arg2;

	return &result;
}

float *
mult_1_svc(float arg1, float arg2,  struct svc_req *rqstp)
{
	static float  result;

	result = arg1 * arg2;

	return &result;
}

float *
div_1_svc(float arg1, float arg2,  struct svc_req *rqstp)
{
	static float  result;

	result = arg1 / arg2;

	return &result;
}

float *
power_1_svc(float arg1, float arg2,  struct svc_req *rqstp)
{
	static float  result;

	result = (float)pow((double)arg1, (double)arg2);

	return &result;
}

float *
sqr_1_svc(float arg1,  struct svc_req *rqstp)
{
	static float  result;

	result = sqrt(arg1);

	return &result;
}

float *
sin_1_svc(float arg1,  struct svc_req *rqstp)
{
	static float  result;

	result = sin(arg1);

	return &result;
}

float *
cos_1_svc(float arg1,  struct svc_req *rqstp)
{
	static float  result;

	result = cos(arg1);

	return &result;
}

float *
tan_1_svc(float arg1,  struct svc_req *rqstp)
{
	static float  result;

	result = tan(arg1);

	return &result;
}

equation *
sumeq_2_svc(equation arg1, equation arg2,  struct svc_req *rqstp)
{
	static equation  result;

	result.equation_len = 3;
	result.equation_val = (float*)malloc(3*sizeof(float));

	for (int i = 0; i < result.equation_len; i++){
		result.equation_val[i] = arg1.equation_val[i] + arg2.equation_val[i];
	}

	return &result;
}

equation *
substracteq_2_svc(equation arg1, equation arg2,  struct svc_req *rqstp)
{
	static equation  result;

	result.equation_len = 3;
	result.equation_val = (float*)malloc(3*sizeof(float));

	for (int i = 0; i < result.equation_len; i++){
		result.equation_val[i] = arg1.equation_val[i] - arg2.equation_val[i];
	}

	return &result;
}

equation *
multeq_2_svc(equation arg1, equation arg2,  struct svc_req *rqstp)
{
	static equation  result;

	result.equation_len = 5;
	result.equation_val = (float*)malloc(5*sizeof(float));
	result.equation_val[0] = arg1.equation_val[0] * arg2.equation_val[0];
	result.equation_val[1] = arg1.equation_val[0] * arg2.equation_val[1] + arg1.equation_val[1] * arg2.equation_val[0];
	result.equation_val[2] = arg1.equation_val[0] * arg2.equation_val[2] + arg1.equation_val[1] * arg2.equation_val[1] + arg1.equation_val[2] * arg2.equation_val[0];
	result.equation_val[3] = arg1.equation_val[1] * arg2.equation_val[2] + arg1.equation_val[2] * arg2.equation_val[1];
	result.equation_val[4] = arg1.equation_val[2] * arg2.equation_val[2];


	return &result;
}

float 
sqrEquation(float a, float b, float c){
	return (float)(pow(b, 2) - 4 * a * c);
}

float
solveFirstGrade(float a, float b){
	return (float)(-b/a);
}

float
solveSecondType(float a, float c){
        return sqrt(-c / a);
}

equation *
solve_2_svc(equation arg1,  struct svc_req *rqstp)
{
	static equation result;
	
	result.equation_len = 2;
	result.equation_val = (float*)malloc(2*sizeof(float));
	if (arg1.equation_val[0] == 0){
		result.equation_len = 1;
		result.equation_val = (float*)malloc(1*sizeof(float));
	}

	float a = arg1.equation_val[0], b = arg1.equation_val[1], c = arg1.equation_val[2];

	float sqrtValue = sqrEquation(a, b, c);

	if (a != 0){			//Si la ecuacion es de segundo grado
		if (arg1.equation_val[1] != 0 && arg1.equation_val[2] != 0){			//Si tiene x², x y c no nulas
				if (sqrEquation(a, b, c) >= 0){	
						result.equation_val[0] = (-b + sqrt(sqrtValue)) / (2 * a);
						result.equation_val[1] = (-b - sqrt(sqrtValue)) / (2 * a);
				}
				else{
						printf("La solución no está en el campo de los reales");
				}
		}
		else if (b == 0 && c != 0){			//Si el término independiente es nulo, x² + x = 0 
				if (a < 0 && c > 0 || a > 0 && c < 0){
						result.equation_val[0] = sqrt(solveFirstGrade(a, c));
						result.equation_val[1] = -sqrt(solveFirstGrade(a, c));
				}
		}
		else if (b != 0 && c == 0){			//Si tiene el término de la x nulo
				result.equation_val[0] = 0;
				result.equation_val[1] = solveFirstGrade(a, b);
		}
		else{								//Si es de la forma a*x²
				result.equation_val[0] = 0;
				result.equation_val[1] = 0;
		}
	}		//Si no, si es de primer grado
	else if (b != 0){
		if (c == 0){				//Si solo es de la forma b*x
			result.equation_val[0] = 0;
		}
		else{						//Si es de la forma b*x + c
			result.equation_val[0] = solveFirstGrade(b, c);
		}
	}
	else{		//Si no tiene grado directamente
		if (c != 0){
			printf("SYNTAX ERROR");
			exit(-1);
		}
		result.equation_val[0] = 0;
	}


        return &result;
}

equation *
sumvec_3_svc(equation arg1, equation arg2,  struct svc_req *rqstp)
{
	static equation  result;

	result.equation_len = 3;
	result.equation_val = (float*)malloc(3*sizeof(float));

	for (int i = 0; i < result.equation_len; ++i){
		result.equation_val[i] = arg1.equation_val[i] + arg2.equation_val[i];
	}

	return &result;
}

equation *
substractvec_3_svc(equation arg1, equation arg2,  struct svc_req *rqstp)
{
	static equation  result;

	result.equation_len = 3;
	result.equation_val = (float*)malloc(3*sizeof(float));

	for (int i = 0; i < result.equation_len; ++i){
		result.equation_val[i] = arg1.equation_val[i] - arg2.equation_val[i];
	}

	return &result;
}

equation *
multvec_3_svc(equation arg1, equation arg2,  struct svc_req *rqstp)
{
	static equation  result;

	result.equation_len = 3;
	result.equation_val = (float*)malloc(3*sizeof(float));

	result.equation_val[0] = (arg1.equation_val[1] * arg2.equation_val[2]) - (arg1.equation_val[2] * arg2.equation_val[1]);
	result.equation_val[1] = -((arg1.equation_val[0] * arg2.equation_val[2]) - (arg1.equation_val[2] * arg2.equation_val[0]));
	result.equation_val[2] = (arg1.equation_val[0] * arg2.equation_val[1]) - (arg1.equation_val[1] * arg2.equation_val[0]);

	return &result;
}

equation *
powervec_3_svc(equation arg1, int arg2,  struct svc_req *rqstp)
{
	static equation  result;

	result.equation_len = 3;
	result.equation_val = (float*)malloc(3*sizeof(float));
	result = arg1;
	for (int i = 1; i < arg2; ++i){
		result = *(multvec_3_svc(result, arg1, rqstp));
	}

	return &result;
}


matrix *
summat_4_svc(matrix arg1, matrix arg2,  struct svc_req *rqstp)
{
	static matrix  result;

	result.matrix_len = 16;
	result.matrix_val = (float*)malloc(16*sizeof(float));

	for (int i = 0; i < arg1.matrix_len; i++){
		result.matrix_val[i] = arg1.matrix_val[i] + arg2.matrix_val[i];
	}

	for (int i = 0; i < arg1.matrix_len; ++i){
		printf("%f ", result.matrix_val[i]);
	}

	return &result;
}

matrix *
substractmat_4_svc(matrix arg1, matrix arg2,  struct svc_req *rqstp)
{
	static matrix  result;

	result.matrix_len = 16;
	result.matrix_val = (float*)malloc(16*sizeof(float));

	for (int i = 0; i < arg1.matrix_len; i++){
		result.matrix_val[i] = arg1.matrix_val[i] - arg2.matrix_val[i];
	}

	return &result;
}

matrix *
multmat_4_svc(matrix arg1, matrix arg2,  struct svc_req *rqstp)
{
	static matrix  result;

	result.matrix_len = 16;
	result.matrix_val = (float*)malloc(16*sizeof(float));
	const int SIZE = 4;
	float mat1[SIZE][SIZE];
	float mat2[SIZE][SIZE];
	float auxiliarMul[SIZE][SIZE];

	for (int i = 0; i < SIZE; i++){
		for (int j = 0; j < SIZE; j++){
			mat1[i][j] = arg1.matrix_val[(4 * i) + j];
			mat2[i][j] = arg2.matrix_val[(4 * i) + j];
		}
	}


	for (int i = 0; i < SIZE; i++){
		for (int j = 0; j < SIZE; j++){
			auxiliarMul[i][j] = 0;
			for (int k = 0; k < SIZE; k++){
				auxiliarMul[i][j] += (mat1[i][k] * mat2[k][j]);
			}
		}
	}


	for (int i = 0; i < SIZE; i++){
		for (int j = 0; j < SIZE; j++){
			result.matrix_val[(4 * i) + j] = auxiliarMul[i][j];
		}
	}

	return &result;
}

matrix *
powermat_4_svc(matrix arg1, int arg2,  struct svc_req *rqstp)
{
	static matrix  result;
	result.matrix_len = 16;
	result.matrix_val = (float*)malloc(16*sizeof(float));

	result = arg1;

	for (int i = 1; i < arg2; i++){
			result = *(multmat_4_svc(result, arg1, rqstp));
	}

	return &result;
}

int 
esPrimo(int arg){
	int primo = 1;

		for (int i = 2; i <= (int)sqrt(arg); i++){
			if (arg % i == 0){
				primo = 0;
				break;
			}
		}
	
	if (arg == 1 || arg == 2 || arg == 3)
		primo = 1;

	return primo;
}

// int *
// fact_5_svc(int arg1,  struct svc_req *rqstp)
// {
// 	int aux[128];
// 	int top = 1;
// 	aux[0] = 1;

// 	for (int i = 2; i <= arg1; i++){
// 		if (esPrimo(i) == 1){
// 			if (arg1 % i == 0){
// 				arg1 = arg1 / i;
// 				aux[top] = i;
// 				top++;
// 				i = 1;
// 			}
// 		}
// 	}
// 	static int result[128];

// 	result[top] = -1;
// 	for (int i = 0; i < top; i++){
// 		result[i] = aux[i];
// 		// printf(" - %i ", result[i]);
// 	}

// 	// printf("%i", result[top]);
// 	// exit(-1);

// 	return &result;
// }

float *
mod_5_svc(float arg1, float arg2,  struct svc_req *rqstp)
{
	static float result;



	int aux = (int)arg1 % (int)arg2; 


	result = (float) aux;
	return &result;
}

decompose *
fact_5_svc(int arg1,  struct svc_req *rqstp)
{
	static decompose  result;
	int aux[256];
	int top = 1;
	aux[0] = 1;

	for (int i = 2; i <= arg1; i++){
		if (esPrimo(i) == 1){
			if (arg1 % i == 0){
				arg1 = arg1 / i;
				aux[top] = i;
				top++;
				i = 1;
			}
		}
	}
	result.decompose_len = top;
	result.decompose_val = (float*)malloc(top * sizeof(float));

	for (int i = 0; i < top; i++){
		result.decompose_val[i] = (float)aux[i];
	}

	return &result;
}